//herein lies all the linear algebra funcs generated by chatGPT

function sign(p1, p2, p3) {
    return (p1.x - p3.x) * (p2.y - p3.y) -
        (p2.x - p3.x) * (p1.y - p3.y);
}


function pointInTriangle(pt, v1, v2, v3) {
    let d1 = sign(pt, v1, v2);
    let d2 = sign(pt, v2, v3);
    let d3 = sign(pt, v3, v1);

    let hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
    let hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

    return !(hasNeg && hasPos);
}

function linePointNearestToPoint(pt, line) {
    const ax = line.origin.x;
    const ay = line.origin.y;
    const bx = line.dest.x;
    const by = line.dest.y;

    const px = pt.x;
    const py = pt.y;

    // vector AB
    const abx = bx - ax;
    const aby = by - ay;

    // vector AP
    const apx = px - ax;
    const apy = py - ay;

    // project AP onto AB, computing parameter t along AB
    const ab2 = abx * abx + aby * aby; // length squared of AB
    let t = (apx * abx + apy * aby) / ab2;

    // clamp t to the segment [0,1]
    t = max(0, min(1, t));

    // nearest point = A + t * AB
    return new Point(ax + abx * t, ay + aby * t);
}

function lineLength(l) {
    var a = l.origin.x - l.dest.x;
    var b = l.origin.y - l.dest.y;

    return Math.sqrt(a * a + b * b);
}


function pointAlongLine(start, end, distance) {
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const length = sqrt(dx * dx + dy * dy);

    // avoid divide by zero
    if (length === 0) return { x: start.x, y: start.y };

    const ux = dx / length;
    const uy = dy / length;

    return {
        x: start.x + ux * distance,
        y: start.y + uy * distance
    };
}

function pointTowards(a, b, n) {
    // vector from A to B
    let dx = b.x - a.x;
    let dy = b.y - a.y;

    // distance between A and B
    let dist = Math.hypot(dx, dy);

    if (dist === 0) {
        // A and B are the same point
        return { x: a.x, y: a.y };
    }

    // unit vector scaled by N
    let ux = dx / dist;
    let uy = dy / dist;

    return {
        x: a.x + ux * n,
        y: a.y + uy * n
    };
}


//not a linear algebra function but was made by chatgpt so keeping it here
function rgbToComplement(r, g, b) {
    // --- Step 1: normalize RGB (0–1 range) ---
    let rn = r / 255, gn = g / 255, bn = b / 255;
    let max = Math.max(rn, gn, bn);
    let min = Math.min(rn, gn, bn);
    let d = max - min;

    // --- Step 2: convert RGB -> HSV ---
    let h, s, v = max;

    if (d === 0) {
        h = 0; // undefined hue
    } else if (max === rn) {
        h = ((gn - bn) / d) % 6;
    } else if (max === gn) {
        h = (bn - rn) / d + 2;
    } else {
        h = (rn - gn) / d + 4;
    }

    h *= 60;
    if (h < 0) h += 360;

    s = max === 0 ? 0 : d / max;

    // --- Step 3: rotate hue 180° ---
    h = (h + 180) % 360;

    // --- Step 4: HSV -> RGB ---
    let c = v * s;
    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
    let m = v - c;

    let r1, g1, b1;
    if (h < 60) {
        [r1, g1, b1] = [c, x, 0];
    } else if (h < 120) {
        [r1, g1, b1] = [x, c, 0];
    } else if (h < 180) {
        [r1, g1, b1] = [0, c, x];
    } else if (h < 240) {
        [r1, g1, b1] = [0, x, c];
    } else if (h < 300) {
        [r1, g1, b1] = [x, 0, c];
    } else {
        [r1, g1, b1] = [c, 0, x];
    }

    let R = Math.round((r1 + m) * 255);
    let G = Math.round((g1 + m) * 255);
    let B = Math.round((b1 + m) * 255);

    return color(R, G, B);
}